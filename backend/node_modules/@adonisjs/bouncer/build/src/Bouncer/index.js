"use strict";
/*
 * @adonisjs/bouncer
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bouncer = void 0;
const Decorators_1 = require("../Decorators");
const BasePolicy_1 = require("../BasePolicy");
const ActionsAuthorizer_1 = require("../ActionsAuthorizer");
/**
 * Bouncer exposes the API for registering authorization actions and policies
 */
class Bouncer {
    constructor(application) {
        this.application = application;
        /**
         * A set of resolved policies. This is to avoid re-importing the same
         * policies again and again
         */
        this.resolvedPolicies = {};
        /**
         * Set of registered actions
         */
        this.actions = {};
        /**
         * Set of registered policies
         */
        this.policies = {};
        /**
         * Set of registered hooks
         */
        this.hooks = {
            before: [],
            after: [],
        };
        /**
         * Reference to the base policy
         */
        this.BasePolicy = BasePolicy_1.BasePolicy;
        this.action = Decorators_1.action;
    }
    /**
     * Register a before hook
     */
    before(callback) {
        this.hooks.before.push(callback);
        return this;
    }
    /**
     * Register an after hook
     */
    after(callback) {
        this.hooks.after.push(callback);
        return this;
    }
    /**
     * Define an authorization action
     */
    define(actionName, handler, options) {
        if (typeof handler !== 'function') {
            throw new Error(`Invalid handler for "${actionName}" action. Must be a function`);
        }
        this.actions[actionName] = { handler, options };
        return this;
    }
    /**
     * Register policies
     */
    registerPolicies(policies) {
        Object.keys(policies).forEach((policy) => {
            if (typeof policies[policy] !== 'function') {
                throw new Error(`Invalid value for "${policy}" policy. Must be a function importing the policy class`);
            }
        });
        this.policies = policies;
        return this;
    }
    /**
     * Returns the authorizer for a given user
     */
    forUser(user) {
        return new ActionsAuthorizer_1.ActionsAuthorizer(user, this);
    }
    /**
     * Deny authorization check using a custom message and status
     */
    deny(message, status) {
        return [message, status || 403];
    }
    /**
     * Resolve policy from the set of pre-registered policies
     */
    async resolvePolicy(policy) {
        /**
         * Return pre-resolved policy
         */
        if (this.resolvedPolicies[policy]) {
            return this.application.container.makeAsync(this.resolvedPolicies[policy]);
        }
        /**
         * Ensure policy is registered
         */
        if (typeof this.policies[policy] !== 'function') {
            throw new Error(`Cannot use "${policy}" policy. Make sure it is defined as a function inside "start/bouncer" file`);
        }
        const policyExport = await this.policies[policy]();
        /**
         * Ensure policy has a default export
         */
        if (!policyExport || !policyExport.default) {
            throw new Error(`Invalid "${policy}" policy. Make sure to export default the policy implementation`);
        }
        policyExport.default.boot();
        return this.application.container.makeAsync(policyExport.default);
    }
}
exports.Bouncer = Bouncer;
