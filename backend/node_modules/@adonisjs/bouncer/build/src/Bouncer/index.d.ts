/// <reference path="../../adonis-typings/index.d.ts" />
/// <reference path="../../adonis-typings/bouncer.d.ts" />
/// <reference path="../../examples/contract.d.ts" />
/// <reference types="@adonisjs/application/build/adonis-typings/application" />
import { BasePolicyContract } from '@ioc:Adonis/Addons/Bouncer';
import { LazyPolicy, ActionOptions, ActionHandler, BouncerContract, AfterHookHandler, BeforeHookHandler } from '@ioc:Adonis/Addons/Bouncer';
import { BasePolicy } from '../BasePolicy';
import { ActionsAuthorizer } from '../ActionsAuthorizer';
import { ApplicationContract } from '@ioc:Adonis/Core/Application';
/**
 * Bouncer exposes the API for registering authorization actions and policies
 */
export declare class Bouncer implements BouncerContract<any, any> {
    private application;
    /**
     * A set of resolved policies. This is to avoid re-importing the same
     * policies again and again
     */
    private resolvedPolicies;
    /**
     * Set of registered actions
     */
    actions: {
        [key: string]: {
            handler: ActionHandler;
            options?: ActionOptions;
        };
    };
    /**
     * Set of registered policies
     */
    policies: {
        [key: string]: LazyPolicy;
    };
    /**
     * Set of registered hooks
     */
    hooks: BouncerContract<any, any>['hooks'];
    /**
     * Reference to the base policy
     */
    BasePolicy: typeof BasePolicy;
    action: import("@ioc:Adonis/Addons/Bouncer").ActionDecorator;
    constructor(application: ApplicationContract);
    /**
     * Register a before hook
     */
    before(callback: BeforeHookHandler): this;
    /**
     * Register an after hook
     */
    after(callback: AfterHookHandler): this;
    /**
     * Define an authorization action
     */
    define<Action extends string>(actionName: Action, handler: ActionHandler, options?: ActionOptions): any;
    /**
     * Register policies
     */
    registerPolicies(policies: {
        [key: string]: LazyPolicy;
    }): any;
    /**
     * Returns the authorizer for a given user
     */
    forUser(user: any): ActionsAuthorizer;
    /**
     * Deny authorization check using a custom message and status
     */
    deny(message: string, status?: number): [string, number];
    /**
     * Resolve policy from the set of pre-registered policies
     */
    resolvePolicy(policy: string): Promise<BasePolicyContract>;
}
