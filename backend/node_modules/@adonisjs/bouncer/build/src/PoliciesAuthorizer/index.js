"use strict";
/*
 * @adonisjs/bouncer
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoliciesAuthorizer = void 0;
const Profiler_1 = require("../Profiler");
const utils_1 = require("../utils");
const AuthorizationException_1 = require("../Exceptions/AuthorizationException");
/**
 * Exposes the API to authorize actions using a policy class
 */
class PoliciesAuthorizer {
    constructor(userOrResolver, bouncer, policy) {
        this.userOrResolver = userOrResolver;
        this.bouncer = bouncer;
        this.policy = policy;
    }
    /**
     * Resolve policy
     */
    async resolvePolicy() {
        if (this.policyInstance) {
            return;
        }
        this.policyInstance = await this.bouncer.resolvePolicy(this.policy);
    }
    /**
     * Resolve the user from the userOrResolver
     * property
     */
    resolveUser() {
        if (this.user) {
            return;
        }
        if (typeof this.userOrResolver === 'function') {
            this.user = this.userOrResolver();
        }
        else {
            this.user = this.userOrResolver;
        }
    }
    /**
     * Run before/after hooks for a given lifecycle phase
     */
    async runHooks(lifecycle, action, result, args, profiler) {
        if (typeof this.policyInstance[lifecycle] !== 'function') {
            return { status: 'skipped' };
        }
        const response = await profiler.profileFunction('bouncer:hook', { lifecycle, action, handler: lifecycle }, this.policyInstance[lifecycle].bind(this.policyInstance), lifecycle === 'before' ? [this.user, action, ...args] : [this.user, action, result, ...args]);
        return utils_1.normalizeHookResponse(response);
    }
    /**
     * Run the action
     */
    async runAction(action, args, profiler) {
        if (typeof this.policyInstance[action] !== 'function') {
            throw new Error(`Cannot run "${action}" action. Make sure it is defined on the "${this.policy}" class`);
        }
        const Policy = this.policyInstance.constructor;
        const options = Policy.actionsOptions[action];
        const allowGuest = options && options.allowGuest;
        /**
         * Disallow when user is missing and guest is not allowed
         */
        if (!this.user && !allowGuest) {
            return utils_1.normalizeActionResponse(false);
        }
        /**
         * Execute action and profile it
         */
        const response = await profiler.profileFunction('bouncer:action', { action, handler: action }, this.policyInstance[action].bind(this.policyInstance), [this.user, ...args]);
        return utils_1.normalizeActionResponse(response);
    }
    /**
     * Run the authorization action
     */
    async authorizeAction(action, args) {
        const profiler = new Profiler_1.AuthorizationProfiler('bouncer:authorize', this.profiler, {
            action,
            policy: this.policy,
        });
        try {
            /**
             * Run before hooks and return the result if status is not "skipped"
             */
            const { status: beforeStatus } = await this.runHooks('before', action, null, args, profiler);
            if (beforeStatus !== 'skipped') {
                return profiler.end(utils_1.normalizeActionResponse(beforeStatus === 'authorized' ? true : false));
            }
            /**
             * Run action handler
             */
            const result = await this.runAction(action, args, profiler);
            /**
             * Run after hooks and return the result if status is not "skipped"
             */
            const { status: afterStatus } = await this.runHooks('after', action, result, args, profiler);
            if (afterStatus !== 'skipped') {
                return profiler.end(utils_1.normalizeActionResponse(afterStatus === 'authorized' ? true : false));
            }
            return profiler.end(result);
        }
        catch (error) {
            profiler.end({
                authorized: false,
                errorMessage: null,
                error,
            });
            throw error;
        }
    }
    /**
     * Set profiler instance to be used for profiling calls
     */
    setProfiler(profiler) {
        this.profiler = profiler;
        return this;
    }
    /**
     * Find if a user is allowed to perform the action
     */
    async allows(action, ...args) {
        await this.resolvePolicy();
        this.resolveUser();
        const { authorized } = await this.authorizeAction(action, args);
        return authorized === true;
    }
    /**
     * Find if a user is not allowed to perform the action
     */
    async denies(action, ...args) {
        await this.resolvePolicy();
        this.resolveUser();
        const { authorized } = await this.authorizeAction(action, args);
        return authorized === false;
    }
    /**
     * Authorize user against the given action
     */
    async authorize(action, ...args) {
        await this.resolvePolicy();
        this.resolveUser();
        const { authorized, errorResponse } = await this.authorizeAction(action, args);
        if (authorized) {
            return;
        }
        throw AuthorizationException_1.AuthorizationException.raise(errorResponse[0], errorResponse[1]);
    }
    /**
     * Create a new authorizer instance for a given user
     */
    forUser(userOrResolver) {
        return new PoliciesAuthorizer(userOrResolver, this.bouncer, this.policy).setProfiler(this.profiler);
    }
}
exports.PoliciesAuthorizer = PoliciesAuthorizer;
