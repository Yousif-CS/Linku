"use strict";
/*
 * @adonisjs/bouncer
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionsAuthorizer = void 0;
const utils_1 = require("@poppinss/utils");
const Profiler_1 = require("../Profiler");
const PoliciesAuthorizer_1 = require("../PoliciesAuthorizer");
const AuthorizationException_1 = require("../Exceptions/AuthorizationException");
const utils_2 = require("../utils");
/**
 * Exposes the API to authorize actions
 */
class ActionsAuthorizer {
    constructor(userOrResolver, bouncer) {
        this.userOrResolver = userOrResolver;
        this.bouncer = bouncer;
    }
    /**
     * Resolve the user from the userOrResolver
     * property
     */
    resolveUser() {
        if (this.user) {
            return;
        }
        if (typeof this.userOrResolver === 'function') {
            this.user = this.userOrResolver();
        }
        else {
            this.user = this.userOrResolver;
        }
    }
    /**
     * Run all hooks for a given lifecycle phase
     */
    async runHooks(lifecycle, action, result, args, profiler) {
        let response;
        for (let hook of this.bouncer.hooks[lifecycle]) {
            /**
             * Execute hook
             */
            response = await profiler.profileFunction('bouncer:hook', { lifecycle, action, handler: hook.name || 'anonymous' }, hook, lifecycle === 'before'
                ? [this.user, action, ...args]
                : [this.user, action, result, ...args]);
            /**
             * Short circuit when response is not undefined or null. Meaning the
             * hook has decided to take over the request
             */
            if (utils_2.hookHasHandledTheRequest(response)) {
                break;
            }
        }
        return utils_2.normalizeHookResponse(response);
    }
    /**
     * Run the action
     */
    async runAction(action, args, profiler) {
        /**
         * We should explicitly raise an exception when the action is not defined.
         */
        if (!this.bouncer.actions[action]) {
            throw new Error(`Cannot run "${action}" action. Make sure it is defined inside the "start/bouncer" file`);
        }
        const { handler, options } = this.bouncer.actions[action];
        const allowGuest = options && options.allowGuest;
        /**
         * Disallow when user is missing and guest is not allowed
         */
        if (!this.user && !allowGuest) {
            return utils_2.normalizeActionResponse(false);
        }
        /**
         * Execute action and profile it
         */
        const response = await profiler.profileFunction('bouncer:action', { action, handler: handler.name || 'anonymous' }, handler, [this.user, ...args]);
        return utils_2.normalizeActionResponse(response);
    }
    /**
     * Run the authorization action
     */
    async authorizeAction(action, args) {
        const profiler = new Profiler_1.AuthorizationProfiler('bouncer:authorize', this.profiler, { action });
        try {
            /**
             * Run before hooks and return the result if status is not "skipped"
             */
            const { status: beforeStatus } = await this.runHooks('before', action, null, args, profiler);
            if (beforeStatus !== 'skipped') {
                return profiler.end(utils_2.normalizeActionResponse(beforeStatus === 'authorized' ? true : false));
            }
            /**
             * Run action handler
             */
            const result = await this.runAction(action, args, profiler);
            /**
             * Run after hooks and return the result if status is not "skipped"
             */
            const { status: afterStatus } = await this.runHooks('after', action, result, args, profiler);
            if (afterStatus !== 'skipped') {
                return profiler.end(utils_2.normalizeActionResponse(afterStatus === 'authorized' ? true : false));
            }
            return profiler.end(result);
        }
        catch (error) {
            profiler.end({
                authorized: false,
                errorMessage: null,
                error,
            });
            throw error;
        }
    }
    /**
     * Set profiler instance to be used for profiling calls
     */
    setProfiler(profiler) {
        this.profiler = profiler;
        return this;
    }
    /**
     * Create a new authorizer instance for a given user
     */
    forUser(userOrResolver) {
        return new ActionsAuthorizer(userOrResolver, this.bouncer).setProfiler(this.profiler);
    }
    /**
     * Returns an instance of the policies authorizer
     */
    with(policy) {
        return new PoliciesAuthorizer_1.PoliciesAuthorizer(this.userOrResolver, this.bouncer, policy).setProfiler(this.profiler);
    }
    /**
     * Find if a user is allowed to perform the action
     */
    async allows(action, ...args) {
        this.resolveUser();
        const { authorized } = await this.authorizeAction(action, args);
        return authorized === true;
    }
    /**
     * Find if a user is not allowed to perform the action
     */
    async denies(action, ...args) {
        this.resolveUser();
        const { authorized } = await this.authorizeAction(action, args);
        return authorized === false;
    }
    /**
     * Authorize user against the given action
     */
    async authorize(action, ...args) {
        this.resolveUser();
        const { authorized, errorResponse } = await this.authorizeAction(action, args);
        if (authorized) {
            return;
        }
        throw AuthorizationException_1.AuthorizationException.raise(errorResponse[0], errorResponse[1]);
    }
    /**
     * Parses the ability arguments passed to "can" and "cannot" methods
     */
    parseAbilityArguments(policyOrAction, args) {
        const tokens = policyOrAction.split('.');
        const usingCustomAuthorizer = args.length && args[0] instanceof ActionsAuthorizer;
        let output = {
            action: policyOrAction,
            authorizer: this,
            args: args,
        };
        if (usingCustomAuthorizer) {
            output.authorizer = args.shift();
            output.args = args;
        }
        if (tokens.length > 1) {
            output.policy = tokens.shift();
            output.action = tokens.join('.');
        }
        return output;
    }
    /**
     * The untyped version of [[this.allows]] and support references a policy.action
     * via string. Added mainly to be used inside the templates.
     *
     * For example:
     * ```
     * bouncer.can('PostPolicy.update', post)
     * ```
     */
    async can(policyOrAction, ...args) {
        if (!policyOrAction) {
            throw new utils_1.Exception('The "can" method expects action name as the first argument');
        }
        const { action, policy, authorizer, args: parsedArgs, } = this.parseAbilityArguments(policyOrAction, args);
        return policy
            ? authorizer.with(policy).allows(action, ...parsedArgs)
            : authorizer.allows(action, ...parsedArgs);
    }
    /**
     * The untyped version of [[this.denies]] and support references a policy.action
     * via string. Added mainly to be used inside the templates.
     *
     * For example:
     * ```
     * bouncer.cannot('PostPolicy.update', post)
     * ```
     */
    async cannot(policyOrAction, ...args) {
        if (!policyOrAction) {
            throw new utils_1.Exception('The "cannot" method expects action name as the first argument');
        }
        const { action, policy, authorizer, args: parsedArgs, } = this.parseAbilityArguments(policyOrAction, args);
        return policy
            ? authorizer.with(policy).denies(action, ...parsedArgs)
            : authorizer.denies(action, ...parsedArgs);
    }
}
exports.ActionsAuthorizer = ActionsAuthorizer;
